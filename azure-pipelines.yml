trigger:
  branches:
    include:
      - main
  paths:
    exclude:
      - azure-pipelines.yml  # Ignora cambios en el archivo del pipeline
      
pool:
  vmImage: 'ubuntu-latest'

variables:
  dockerRegistryServiceConnection: 'DockerHub' # La Service Connection a Docker Hub
  sonarQubeServiceConnection: 'SonarQube' # La Service Connection a SonarQube
  imageName: '$(DockerImageName)' # Nombre de la imagen en Docker Hub (sin etiquetas)
  imageTag: '$(Build.BuildId)'  # Tag dinámico basado en el ID de la build

stages:
- stage: Build
  displayName: Build and Push Docker Image
  jobs:
  - job: Build
    displayName: Build Job
    steps:
    # Clonar el repositorio y deshabilitar shallow fetch
    - checkout: self
      displayName: "Clonar el repositorio"
      fetchDepth: 0

    # Preparar el análisis de SonarQube
    - task: SonarQubePrepare@7
      displayName: "Preparar análisis de SonarQube"
      inputs:
        SonarQube: $(sonarQubeServiceConnection)
        scannerMode: 'cli'
        configMode: 'manual'
        cliProjectKey: '$(SONARQUBE_PROJECT_KEY)'

    # Agregar tareas de construcción aquí si las necesitas para análisis de SonarQube
    - script: |
        echo "Compilando o preparando el proyecto para análisis..."
        # Aquí puedes ejecutar compilación, pruebas, o pasos previos necesarios para SonarQube
      displayName: "Construir y preparar para SonarQube"

    # Ejecutar el análisis de código
    - task: SonarQubeAnalyze@7
      displayName: "Ejecutar análisis de SonarQube"
      inputs:
        jdkversion: 'JAVA_HOME_17_X64'

#    # Publicar los resultados del análisis en SonarQube
#    - task: SonarQubePublish@7
#      displayName: "Publicar resultados de SonarQube"
#      inputs:
#        pollingTimeoutSec: '300'

    # Autenticarse en Docker Hub
    - task: Docker@2
      displayName: "Login en Docker Hub"
      inputs:
        command: login
        containerRegistry: $(dockerRegistryServiceConnection)

    # Construir la nueva imagen usando el Dockerfile en la carpeta app
    - task: Docker@2
      displayName: "Construir imagen Docker desde app/Dockerfile"
      inputs:
        command: build
        dockerfile: app/Dockerfile         # Ruta al Dockerfile en la carpeta app
        buildContext: app                  # Contexto de construcción
        containerRegistry: $(dockerRegistryServiceConnection)
        repository: $(imageName)           # Nombre de la imagen
        tags: |
          $(imageTag)

    # Subir la imagen construida a Docker Hub
    - task: Docker@2
      displayName: "Push de la imagen a Docker Hub"
      inputs:
        command: push
        containerRegistry: $(dockerRegistryServiceConnection)
        repository: $(imageName)
        tags: |
          $(imageTag)
    
- stage: Deploy
  displayName: "Deploy to EKS"
  dependsOn: Build
  jobs:
  - job: Deploy
    displayName: Deploy to Kubernetes
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: Kubernetes@1
      displayName: "Test Kubernetes Connection"
      inputs:
        kubernetesServiceEndpoint: 'KubernetesConnection'
        command: 'get'
        arguments: 'nodes'
    - task: Kubernetes@1
      displayName: "Set Kubernetes Context"
      inputs:
        kubernetesServiceEndpoint: 'KubernetesConnection' # Cambia 'kubernetesServiceConnection' a 'kubernetesServiceEndpoint'
        namespace: $(kubernetesNamespace)
    - script: |
        kubectl apply -f namespace.yml
        kubectl apply -f deployment.yml
        kubectl apply -f server.yml
        kubectl apply -f ingress.yml
      displayName: Deploy Kubernetes Manifests